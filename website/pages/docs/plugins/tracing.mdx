---
name: Tracing plugin
title: Tracing plugin for Pothos GraphQL
menu: Plugins
description: A Pothos plugin for tracing and logging resolver invocations
---

import { DocsPage } from '../../../components/Docs/Page';
import { buildNav } from '../../../util/build-nav';

export default DocsPage;

export const getStaticProps = () => ({ props: { nav: buildNav() } });

# Tracing Plugin

This plugin adds hooks for tracing and logging resolver invocations. It also comes with a few
additional packages for integrating with various tracing providers including opentelemetry, New
Relic and Sentry.

## Usage

### Install

```bash
yarn add @pothos/plugin-tracing
```

### Setup

```typescript
import TracingPlugin, { wrapResolver, isRootField } from '@pothos/plugin-tracing';

const builder = new SchemaBuilder({
  plugins: [TracingPlugin],
  tracing: {
    // Enable tracing for rootFields by default, other fields need to opt in
    default: (config) => isRootField(config),
    // Log resolver execution duration
    wrap: (resolver, options, config) =>
      wrapResolver(resolver, (error, duration) => {
        console.log(`Executed resolver ${config.parentType}.${config.name} in ${duration}ms`);
      }),
  },
});
```

### Overview

The Tracing plugin is designed to have very limited overhead, and uses a modular approach to cover a
wide variety of use cases.

The tracing plugin comes with a number of utility functions for implementing common patterns, and a
couple of provider specific modules that can be installed separately (described in more detail
below).

The primary interface to the tracing plugin consists of 3 parts:

1. A new `tracing` option is added to each field, for enabling or configuring tracing for that field
2. The `tracing.default` which is used as a fallback for any field that does not explicitly set its
   `tracing` options.
3. The `tracing.wrap` function, which takes a resolver, the tracing option for a field, and a field
   configuration object, and should return a wrapped/traced version of the resolver.

### Enabling tracing for a field

Enabling tracing on a field is as simple as setting the tracing option to `true`

```ts
builder.queryType({
  fields: (t) => ({
    hello: t.string({
      // enable tracing
      tracing: true,
      resolve: (parent, { name }) => `hello, ${name || 'World'}`,
    }),
  }),
});
```

#### Custom tracing options

For more advanced tracing setups, you may want to allow fields to provide additional tracing
options. You can do this by customizing the `Tracing` generic in the builder.

```ts
import TracingPlugin, { wrapResolver, isRootField } from '@pothos/plugin-tracing';

export const builder = new SchemaBuilder<{
  // the `tracing` option can now be a boolean, or an object with a formatMessage function
  Tracing: boolean | { formatMessage: (duration: number) => string };
}>({
  plugins: [TracingPlugin],
  tracing: {
    // Using custom options in your tracer will be described below
    ...
  },
});

builder.queryType({
  fields: (t) => ({
    hello: t.string({
      // We can now use custom options when configuring tracing
      tracing: { formatMessage: (duration) => `It took ${duration}ms to say hello` },
      resolve: (parent, { name }) => `hello, ${name || 'World'}`,
    }),
  }),
});
```

### Enabling tracing by default

In most applications you won't want to configure tracing for each field. Instead you can use the
`tracing.default` to enable tracing for specific types of fields.

```ts
import TracingPlugin, { wrapResolver, isRootField } from '@pothos/plugin-tracing';

export const builder = new SchemaBuilder<{
  Tracing: boolean | { formatMessage: (duration: number) => string };
}>({
  plugins: [TracingPlugin],
  tracing: {
    // Here we enable tracing for root fields
    default: (config) => isRootField(config)
    wrap: (resolve) => resolve, // actual tracing wrappers will be described below
  },
});
```

There are a number of utility functions for detecting certain types of fields. For most applications
tracing every resolver will add significant overhead with very little benefit. The following
utilities exported by the tracing plugin can be used to determine which fields should have tracing
enabled by default.

- `isRootField`: Returns true for fields of the `Query`, `Mutation`, and `Subscription` types
- `isScalarField`: Returns true for fields that return Scalars, or lists of scalars
- `isEnumField`: Returns true for fields that return an Enum or list of Enums
- `isExposedField`: Returns true for fields defined with the `t.expose*` field builder methods, or
  fields that use the `defaultFieldResolver`.

### Implementing a tracer

Tracers work by wrapping the execution of resolver calls. The `tracing.wrap` function keeps this
process as minimal as possible by simply providing the resolver for a field, and expecting a wrapped
version of the resolver to be returned. Resolvers can throw errors or return promises, and correctly
handling these edge cases can be a little complicated so the tracing plugin also comes with some
helpers utilities to simplify this process.

`tracing.wrap` takes 3 arguments:

1. `resolver`: the resolver for a field
2. `options`: the tracing options for the field (set either on the field, or returned by
   `tracing.default`).
3. `fieldConfig`: A config object that describes the field being wrapped

```ts
export const builder = new SchemaBuilder<{
  Tracing: boolean | { formatMessage: (duration: number) => string };
}>({
  plugins: [TracingPlugin],
  tracing: {
    default: (config) => isRootField(config),
    wrap: (resolver, options, config) =>
      wrapResolver(resolver, (error, duration) => {
        const message =
          typeof options === 'object'
            ? options.formatMessage(duration)
            : `Executed resolver ${config.parentType}.${config.name} in ${duration}ms`;

        console.log(message);
      }),
  },
});
```

The `wrapResolver` utility takes a resolver, and a `onEnd` callback, and returns a wrapped version
of the resolver that will call the callback with an error (or null) and the duration the resolver
took to complete.

The `runFunction` helper is similar, but rather than wrapping a resolver, will immediately execute a
function with no arguments. This can be useful for more complex use cases where you need access to
other resolver arguments, or want to add your own logic before the resolver begins executing.

```ts
export const builder = new SchemaBuilder<{
  Tracing: boolean | { formatMessage: (duration: number) => string };
}>({
  plugins: [TracingPlugin],
  tracing: {
    default: (config) => isRootField(config) || (!isScalarField(config) && !isEnumField(config)),
    wrap: (resolver, options) => (source, args, ctx, info) => {
      doSomethingFirst(args);

      return runFunction(
        () => resolver(source, args, ctx, info),
        (error, duration) => {
          console.log(
            `Executed resolver for ${info.parentType}.${info.fieldName} in ${duration}ms`,
          );
        },
      );
    },
  },
});
```

## Tracing integrations

### Opentelemetry

#### install

```bash
yarn add @pothos/tracing-opentelemetry
```

#### Basic usage

```ts
import SchemaBuilder from '@pothos/core';
import TracingPlugin, { isRootField } from '@pothos/plugin-tracing';
import { createOpenTelemetryWrapper } from '@pothos/tracing-opentelemetry';
import { tracer } from './tracer';

const createSpan = createOpenTelemetryWrapper(tracer, {
  includeSource: true,
});

export const builder = new SchemaBuilder({
  plugins: [TracingPlugin],
  tracing: {
    default: (config) => isRootField(config),
    wrap: (resolver, options) => createSpan(resolver, options),
  },
});
```

#### options

- `includeArgs`: default: `false`
- `includeSource`: default: `false`
- `ignoreError`: default: `false`
- `onSpan`: `(span, tracingOptions, parent, args, context, info) => void`

#### Instrumenting the execution phase

```ts

```

### New Relic

#### install

```bash
yarn add @pothos/tracing-newrelic
```

#### Basic usage

```ts
import SchemaBuilder from '@pothos/core';
import TracingPlugin, { isRootField } from '@pothos/plugin-tracing';
import { createNewrelicWrapper } from '@pothos/tracing-newrelic';

const wrapResolver = createNewrelicWrapper({
  includeArgs: true,
  includeSource: true,
});

export const builder = new SchemaBuilder({
  plugins: [TracingPlugin],
  tracing: {
    default: (config) => isRootField(config),
    wrap: (resolver) => wrapResolver(resolver),
  },
});
```

#### options

- `includeArgs`: default: `false`
- `includeSource`: default: `false`

#### Instrumenting the execution phase

```ts

```

### Sentry

#### install

```bash
yarn add @pothos/tracing-sentry
```

#### Basic usage

```ts
import SchemaBuilder from '@pothos/core';
import TracingPlugin, { isRootField } from '@pothos/plugin-tracing';
import { createSentryWrapper } from '@pothos/tracing-sentry';

const traceResolver = createSentryWrapper({
  includeArgs: true,
  includeSource: true,
});

export const builder = new SchemaBuilder({
  plugins: [TracingPlugin],
  tracing: {
    default: (config) => isRootField(config),
    wrap: (resolver, options) => traceResolver(resolver, options),
  },
});
```

#### options

- `includeArgs`: default: `false`
- `includeSource`: default: `false`
- `ignoreError`: default: `false`

#### Instrumenting the execution phase

```ts

```
